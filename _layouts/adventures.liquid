---
layout: default
---
{% if page._styles %}
  <!-- Page/Post style -->
  <style type="text/css">
    {{ page._styles }}
  </style>
{% endif %}

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@{{ site.third_party_libraries.leaflet.version }}/dist/leaflet.min.css" 
      integrity="{{ site.third_party_libraries.leaflet.integrity.css }}" crossorigin="anonymous" />

<style>
.life-travels-container {
  margin-top: 2rem;
  padding-bottom: 4rem;
}

.stories-timeline {
  display: flex;
  flex-direction: column;
  gap: 4rem;
  margin-top: 2rem;
  position: relative;
}

.year-indicator {
  position: sticky;
  top: 1rem;
  left: -5rem;
  width: 4rem;
  height: 4rem;
  background: var(--global-theme-color);
  color: white;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.9rem;
  letter-spacing: 0.05em;
  z-index: 10;
  margin-bottom: -2rem;
  align-self: flex-start;
}

.story-item {
  position: relative;
}

.story-card {
  background: var(--global-bg-color);
  border: 2px solid var(--global-divider-color);
  border-radius: 0;
  padding: 0;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
  transition: all 0.2s ease;
}

.story-card {
  cursor: pointer;
}

.story-card:hover {
  border-color: var(--global-theme-color);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  transform: translateY(-1px);
}

.story-item.selected .story-card {
  border-color: var(--global-theme-color);
  background: linear-gradient(90deg, 
    rgba(89, 125, 206, 0.05) 0%, 
    rgba(89, 125, 206, 0.02) 100%);
  box-shadow: 0 8px 32px rgba(89, 125, 206, 0.15);
  transform: translateY(-2px);
}

.story-item.selected .story-title {
  color: var(--global-theme-color);
  font-weight: 600;
}

.story-item.selected .deselect-button {
  display: flex;
}

.deselect-button {
  display: none;
  position: absolute;
  top: 10px;
  right: 10px;
  width: 24px;
  height: 24px;
  background: var(--global-theme-color);
  color: white;
  border: none;
  border-radius: 50%;
  font-size: 16px;
  line-height: 1;
  cursor: pointer;
  z-index: 20;
  transition: all 0.2s ease;
  align-items: center;
  justify-content: center;
}

.deselect-button:hover {
  background: #2d5aa0;
  transform: scale(1.1);
}

.story-header {
  padding: 2rem 2rem 1.5rem 2rem;
  border-bottom: 2px solid var(--global-divider-color);
}

.story-meta {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 0.8rem;
  color: var(--global-text-color-light);
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  font-weight: 500;
}

.story-date {
  font-weight: 600;
  color: var(--global-theme-color);
}

.story-location {
  position: relative;
  padding-left: 0.75rem;
}

.story-location::before {
  content: "•";
  position: absolute;
  left: 0;
  color: var(--global-divider-color);
}

.story-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--global-text-color);
  margin-bottom: 1rem;
  line-height: 1.2;
  letter-spacing: -0.02em;
}

.story-content {
  font-size: 1rem;
  line-height: 1.7;
  color: var(--global-text-color);
  margin: 0;
}

.story-photos {
  padding: 0;
}

.photos-grid {
  display: grid;
  gap: 2px;
  border: 2px solid var(--global-divider-color);
  border-top: none;
}

.photos-grid.single-photo {
  grid-template-columns: 1fr;
}

.photos-grid.two-photos {
  grid-template-columns: 1fr 1fr;
}

.photos-grid.three-photos {
  grid-template-columns: 1fr 1fr 1fr;
}

.photos-grid.many-photos {
  grid-template-columns: repeat(2, 1fr);
}

.photo-container {
  position: relative;
  overflow: hidden;
  aspect-ratio: 4/3;
  cursor: pointer;
  background: var(--global-bg-color);
}

.photo-container figure {
  margin: 0;
  width: 100%;
  height: 100%;
}

.photo-container picture {
  width: 100%;
  height: 100%;
  display: block;
}

.photo-container img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center center;
  transition: all 0.2s ease;
}

.photo-container.focus-top img {
  object-position: center top;
}

.photo-container.focus-bottom img {
  object-position: center bottom;
}

.photo-container.focus-left img {
  object-position: left center;
}

.photo-container.focus-right img {
  object-position: right center;
}

.photo-container.focus-top-left img {
  object-position: left top;
}

.photo-container.focus-top-right img {
  object-position: right top;
}

.photo-container.focus-bottom-left img {
  object-position: left bottom;
}

.photo-container.focus-bottom-right img {
  object-position: right bottom;
}

.photo-container:hover img {
  transform: scale(1.02);
  filter: brightness(1.05);
}


/* Photo Modal Styles */
.photo-modal {
  display: none;
  position: fixed;
  z-index: 9999;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  backdrop-filter: blur(5px);
}

.photo-modal.active {
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

.photo-modal-content {
  max-width: 95vw;
  max-height: 95vh;
  width: auto;
  position: relative;
  display: flex;
  flex-direction: column;
  background: white;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  padding: 2rem 2rem 1rem 2rem;
  box-sizing: border-box;
  min-width: 0;
}

.photo-modal-image {
  max-width: 91vw;
  max-height: 80vh;
  width: auto;
  height: auto;
  object-fit: contain;
  background: #f8f9fa;
  display: block;
  position: relative;
}

.photo-modal-caption {
  padding: 0.5rem 1rem 1rem 1rem;
  background: transparent;
  color: inherit;
  font-size: 1rem;
  line-height: 1.5;
  max-height: 30vh;
  width: auto;
  max-width: none;
  box-sizing: border-box;
  overflow-y: auto;
  overflow-x: hidden;
  word-wrap: break-word;
  word-break: break-word;
  hyphens: auto;
  margin-top: 0.5rem;
  flex-shrink: 1;
  min-height: 0;
  display: block;
  white-space: normal;
  position: relative;
  
  /* Custom scrollbar styling */
  scrollbar-width: thin;
  scrollbar-color: rgba(0,0,0,0.3) transparent;
}


.photo-modal-caption::-webkit-scrollbar {
  width: 6px;
}

.photo-modal-caption::-webkit-scrollbar-track {
  background: transparent;
}

.photo-modal-caption::-webkit-scrollbar-thumb {
  background: rgba(0,0,0,0.3);
  border-radius: 3px;
}

.photo-modal-caption::-webkit-scrollbar-thumb:hover {
  background: rgba(0,0,0,0.5);
}

.photo-modal-close {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  border: none;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  font-size: 1.4rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 10001;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
}

.photo-modal-close:hover {
  background: rgba(0, 0, 0, 0.95);
  transform: scale(1.1);
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  /* Prevent horizontal scroll */
  body {
    overflow-x: hidden;
  }
  
  .post {
    overflow-x: hidden;
  }
  
  .stories-timeline {
    gap: 3rem;
  }
  
  .year-indicator {
    position: relative;
    left: 0;
    margin-left: 0;
    margin-bottom: 1rem;
    align-self: center;
  }
  
  
  .story-header {
    padding: 1.5rem;
  }
  
  .story-meta {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  
  .story-location {
    padding-left: 0;
  }
  
  .story-location::before {
    display: none;
  }
  
  .story-title {
    font-size: 1.3rem;
  }
  
  .photos-grid.two-photos,
  .photos-grid.three-photos,
  .photos-grid.many-photos {
    grid-template-columns: 1fr;
  }
  
  .story-card {
    max-width: 100%;
    overflow: hidden;
  }
  
  .photo-container {
    max-width: 100%;
  }
  
  .photo-caption {
    padding: 0.75rem;
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .story-header {
    padding: 1.25rem;
  }
  
  .story-title {
    font-size: 1.2rem;
  }
  
  .story-content {
    font-size: 0.95rem;
  }
}

/* Dark mode adjustments */
html[data-theme="dark"] .story-card {
  background: var(--global-bg-color);
  border-color: var(--global-divider-color);
}

html[data-theme="dark"] .story-card:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

/* Adventure Map and Filters */
.adventure-controls {
  margin-bottom: 3rem;
}

.adventure-map-container {
  margin-bottom: 2rem;
}

.adventure-map {
  height: 400px;
  width: 100%;
  border: 2px solid var(--global-divider-color);
  background: var(--global-bg-color);
}

/* Custom Map Pins */
.custom-map-icon {
  background: none !important;
  border: none !important;
}

.map-pin {
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}

.map-pin:hover {
  transform: scale(1.2);
  box-shadow: 0 0 12px rgba(66, 133, 244, 0.8), 0 2px 4px rgba(0,0,0,0.3);
}

.single-pin {
  background: #4285f4;
  border: 2px solid white;
  box-shadow: 0 0 8px rgba(66, 133, 244, 0.6), 0 1px 3px rgba(0,0,0,0.3);
  width: 16px;
  height: 16px;
}

.multi-pin {
  background: #4285f4;
  width: 16px;
  height: 16px;
  box-shadow: 0 0 8px rgba(66, 133, 244, 0.6), 0 1px 3px rgba(0,0,0,0.3);
  border: 2px solid white;
}

/* Add a subtle pulse animation for all pins */
.map-pin::before {
  content: '';
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border-radius: 50%;
  background: rgba(66, 133, 244, 0.15);
  animation: pulse 3s ease-in-out infinite;
}

@keyframes pulse {
  0% {
    transform: scale(0.8);
    opacity: 0.8;
  }
  50% {
    transform: scale(1.5);
    opacity: 0;
  }
  100% {
    transform: scale(0.8);
    opacity: 0.8;
  }
}

/* Map Popup Styles */
.map-popup h4 {
  margin: 0 0 0.5rem 0;
  color: var(--global-text-color);
  font-size: 1rem;
  font-weight: 600;
}

.map-popup p {
  margin: 0;
  font-size: 0.85rem;
  color: #666;
}

.adventure-list {
  margin-top: 0.75rem;
}

.adventure-item {
  font-size: 0.8rem;
  color: var(--global-text-color);
  margin: 0.25rem 0;
  line-height: 1.3;
}

.adventure-filters {
  width: 100%;
}

.year-filters {
  display: flex;
  flex-wrap: nowrap;
  gap: 0.4rem;
  justify-content: center;
  width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}


.filter-btn {
  background: var(--global-bg-color);
  border: 2px solid var(--global-divider-color);
  color: var(--global-text-color);
  padding: 0.5rem 0.8rem;
  border-radius: 0;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
  transition: all 0.2s ease;
  flex: 1;
  min-width: 0;
  text-align: center;
}

.filter-btn:hover {
  border-color: var(--global-theme-color);
  background: var(--global-theme-color);
  color: white;
}

.filter-btn.highlighted {
  background: #e3f2fd;
  border-color: #90caf9;
  color: var(--global-text-color);
}

/* Ensure active buttons always override highlighting */
.filter-btn.active {
  background: var(--global-theme-color) !important;
  border-color: var(--global-theme-color) !important;
  color: white !important;
}


.story-item {
  transition: opacity 0.3s ease;
}

.story-item.hidden {
  display: none;
}

/* Responsive */
@media (max-width: 768px) {
  .adventure-map {
    height: 300px;
  }
  
  .year-filters {
    justify-content: flex-start;
    flex-wrap: wrap;
    overflow-x: visible;
    max-width: 100%;
  }
  
  .filter-btn {
    padding: 0.4rem 0.6rem;
    font-size: 0.85rem;
    flex: 0 0 auto;
    min-width: 60px;
    white-space: nowrap;
  }
  
  .photo-modal-caption {
    font-size: 0.9rem;
    max-height: 25vh;
    padding: 0.8rem 0 1rem 0;
  }
  
  .photo-modal-content {
    padding: 1.5rem;
    max-width: 98vw;
    max-height: 95vh;
  }
  
  .photo-modal-image {
    max-width: 94vw;
    max-height: 75vh;
  }
}
</style>

<div class="post">
  <header class="post-header">
    <h1 class="post-title">{{ page.title }}</h1>
    <p class="post-description">{{ page.description }}</p>
  </header>

  <article>
    {{ content }}
    
    {% assign adventures = site.adventures | sort: 'date' | reverse %}
    {% if adventures.size > 0 %}
    <!-- Adventure Map and Filters -->
    <div class="adventure-controls">
      <div class="adventure-map-container">
        <div id="adventure-map" class="adventure-map"></div>
      </div>
      
      <div class="adventure-filters">
        <div class="year-filters" id="year-filters">
          {% assign current_year = "now" | date: "%Y" | plus: 0 %}
          {% for year in (2015..current_year) reversed %}
            <button class="filter-btn" data-year="{{ year }}">{{ year }}</button>
          {% endfor %}
        </div>
      </div>
    </div>
    
    <div class="life-travels-container">
      <div class="stories-timeline" id="stories-timeline">
        {% for story in adventures %}
          {% assign story_year = story.date | date: "%Y" %}
          {% assign story_location = story.location | default: "Unknown" %}
          {% assign adventure_id = story.title | downcase | replace: ' ', '-' | replace: '[^a-z0-9-]', '' %}
          {% assign story_date_formatted = story.date | date: "%Y-%m-%d" %}
          {% assign adventure_id = adventure_id | append: '-' | append: story_date_formatted %}
          <div class="story-item" data-year="{{ story_year }}" data-location="{{ story_location }}" data-coordinates="{{ story.coordinates }}" data-adventure-id="{{ adventure_id }}" data-adventure-title="{{ story.title }}" data-adventure-date="{{ story.date }}">
            <button class="deselect-button" title="Deselect adventure">&times;</button>
            <article class="story-card">
              <header class="story-header">
                <div class="story-meta">
                  {% if story.end_date %}
                    {% assign start_month = story.date | date: "%B" %}
                    {% assign end_month = story.end_date | date: "%B" %}
                    {% assign start_year = story.date | date: "%Y" %}
                    {% assign end_year = story.end_date | date: "%Y" %}
                    
                    {% if start_year == end_year %}
                      {% if start_month == end_month %}
                        <time class="story-date">{{ start_month }} {{ start_year }}</time>
                      {% else %}
                        <time class="story-date">{{ start_month }} - {{ end_month }} {{ start_year }}</time>
                      {% endif %}
                    {% else %}
                      <time class="story-date">{{ start_month }} {{ start_year }} - {{ end_month }} {{ end_year }}</time>
                    {% endif %}
                  {% else %}
                    <time class="story-date">{{ story.date | date: "%B %Y" }}</time>
                  {% endif %}
                  {% if story.location %}
                    <span class="story-location">{{ story.location }}</span>
                  {% endif %}
                </div>
                <h2 class="story-title">{{ story.title }}</h2>
                <p class="story-content">{{ story.story }}</p>
              </header>
              
              {% if story.photos %}
              <div class="story-photos">
                {% assign photo_count = story.photos.size %}
                {% if photo_count == 1 %}
                  {% assign grid_class = "single-photo" %}
                {% elsif photo_count == 2 %}
                  {% assign grid_class = "two-photos" %}
                {% elsif photo_count == 3 %}
                  {% assign grid_class = "three-photos" %}
                {% else %}
                  {% assign grid_class = "many-photos" %}
                {% endif %}
                
                <div class="photos-grid {{ grid_class }}">
                  {% for photo in story.photos %}
                    {% if photo.focus %}
                      {% assign focus_class = "focus-" | append: photo.focus %}
                    {% else %}
                      {% assign focus_class = "" %}
                    {% endif %}
                    <div class="photo-container {{ focus_class }}" 
                         data-image="{{ photo.image }}"
                         data-caption="{{ photo.caption }}"
                         data-long-caption="{{ photo.long_caption | default: photo.caption }}"
                         data-focus="{{ photo.focus | default: 'center' }}"
                      {% assign photo_path = '/assets/img/adventures/' | append: photo.image %}
                      {% include figure.liquid 
                        path=photo_path
                        class="story-photo"
                        alt=photo.caption
                        title=photo.caption
                      %}
                    </div>
                  {% endfor %}
                </div>
              </div>
              {% endif %}
            </article>
          </div>
        {% endfor %}
      </div>
    </div>
    {% endif %}
  </article>
</div>

<!-- Photo Modal -->
<div id="photo-modal" class="photo-modal">
  <div class="photo-modal-content">
    <div class="photo-modal-image-container" style="position: relative; display: inline-block;">
      <img id="photo-modal-image" class="photo-modal-image" src="" alt="">
      <button class="photo-modal-close" id="photo-modal-close">&times;</button>
    </div>
    <div id="photo-modal-caption" class="photo-modal-caption"></div>
  </div>
</div>

<!-- Hidden canvas for color extraction -->
<canvas id="color-extraction-canvas" style="display: none;"></canvas>

{% if adventures.size > 0 %}
<!-- Leaflet JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/leaflet@{{ site.third_party_libraries.leaflet.version }}/dist/leaflet.min.js"
        integrity="{{ site.third_party_libraries.leaflet.integrity.js }}" crossorigin="anonymous"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Helper function to track events in Umami
  function trackEvent(eventName, eventData = {}) {
    if (typeof umami !== 'undefined') {
      umami.track(eventName, eventData);
    }
  }
  
  // Adventure data from Jekyll - extract photo locations
  const adventures = [
    {% for story in adventures %}
    {
      title: {{ story.title | jsonify }},
      location: {{ story.location | jsonify }},
      date: {{ story.date | date: "%Y-%m-%d" | jsonify }},
      year: {{ story.date | date: "%Y" | jsonify }},
      story: {{ story.story | jsonify }},
      photos: [
        {% for photo in story.photos %}
        {
          image: {{ photo.image | jsonify }},
          caption: {{ photo.caption | jsonify }},
          coordinates: {{ photo.coordinates | jsonify }}
        }{% unless forloop.last %},{% endunless %}
        {% endfor %}
      ]
    }{% unless forloop.last %},{% endunless %}
    {% endfor %}
  ];

  // Extract all photo locations across all adventures
  const photoLocations = [];
  adventures.forEach(adventure => {
    if (adventure.photos) {
      adventure.photos.forEach(photo => {
        if (photo.coordinates) {
          photoLocations.push({
            ...photo,
            adventure: adventure,
            adventureTitle: adventure.title,
            adventureLocation: adventure.location,
            adventureYear: adventure.year,
            adventureStory: adventure.story
          });
        }
      });
    }
  });

  // Initialize map
  let map, markers = [];
  let currentZoomLevel = 4;
  let activeLocationFilter = null;
  let isInitialized = false;
  let activeYearFilter = null;
  let activeAdventureFilter = null;
  
  // Function to zoom map to fit an adventure's locations
  function zoomToAdventure(adventure) {
    if (!adventure.photos || adventure.photos.length === 0) return;
    
    const coordinates = [];
    
    // Collect all photo coordinates for this adventure
    adventure.photos.forEach(photo => {
      if (photo.coordinates) {
        const [lat, lng] = photo.coordinates.split(',').map(coord => parseFloat(coord.trim()));
        if (!isNaN(lat) && !isNaN(lng)) {
          coordinates.push([lat, lng]);
        }
      }
    });
    
    if (coordinates.length === 0) return;
    
    if (coordinates.length === 1) {
      // Single location - zoom to a reasonable level
      map.setView(coordinates[0], 12);
    } else {
      // Multiple locations - fit bounds with buffer
      const bounds = L.latLngBounds(coordinates);
      
      // Add 20% buffer around the bounds
      const center = bounds.getCenter();
      const northeast = bounds.getNorthEast();
      const southwest = bounds.getSouthWest();
      
      // Calculate the current span
      const latSpan = northeast.lat - southwest.lat;
      const lngSpan = northeast.lng - southwest.lng;
      
      // Add 20% buffer (10% on each side)
      const bufferLat = latSpan * 0.1;
      const bufferLng = lngSpan * 0.1;
      
      // Create new bounds with buffer
      const bufferedBounds = L.latLngBounds([
        [southwest.lat - bufferLat, southwest.lng - bufferLng],
        [northeast.lat + bufferLat, northeast.lng + bufferLng]
      ]);
      
      map.fitBounds(bufferedBounds, {
        animate: true,
        duration: 0.5
      });
    }
  }

  // Update year button highlighting based on visible adventures
  function updateYearButtonHighlighting(locationGroups) {
    const yearButtons = document.querySelectorAll('[data-year]');
    
    // Get all years that have adventures currently visible on the map
    const visibleYears = new Set();
    locationGroups.forEach(group => {
      group.adventuresList.forEach(adventure => {
        visibleYears.add(adventure.year);
      });
    });
    
    // Update button styling
    yearButtons.forEach(button => {
      const buttonYear = button.getAttribute('data-year');
      const isActive = button.classList.contains('active');
      
      // Don't modify highlighting for the active (selected) year button
      if (isActive) {
        // Keep the active year button as-is (dark blue)
        return;
      }
      
      // For non-active buttons, update highlighting based on visibility
      button.classList.remove('highlighted');
      if (visibleYears.has(buttonYear)) {
        button.classList.add('highlighted');
      }
    });
  }
  
  function initMap() {
    if (!isInitialized) {
      // Create map centered on US
      // Detect mobile and adjust initial view
      const isMobile = window.innerWidth <= 768;
      const initialZoom = isMobile ? 3 : 4;
      const initialCenter = isMobile ? [39.8283, -98.5795] : [39.8283, -98.5795];
      
      map = L.map('adventure-map').setView(initialCenter, initialZoom);
      
      // Add tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);
      
      // Add zoom event listener only once
      map.on('zoomend', function() {
        const newZoom = map.getZoom();
        if (Math.abs(newZoom - currentZoomLevel) >= 1) {
          currentZoomLevel = newZoom;
          drawMarkers(); // Just redraw markers, don't recreate map
          
          // Always filter to current map view after zoom (since markers have changed)
          setTimeout(() => {
            filterToMapView();
          }, 200); // Slightly longer delay to ensure markers are drawn
        }
      });
      
      // Add pan event listener to update highlighting when map moves
      map.on('moveend', function() {
        // Update year highlighting and story filtering when map viewport changes
        setTimeout(() => {
          filterToMapView();
        }, 100);
      });
      
      isInitialized = true;
    }
    
    drawMarkers();
  }

  function drawMarkers() {
    
    // Clear existing markers
    markers.forEach(marker => map.removeLayer(marker));
    markers = [];
    
    // Determine clustering distance based on zoom level (in kilometers)
    let clusterDistance = 200; // Default clustering distance at country level (200km)
    if (map.getZoom() >= 5) clusterDistance = 100;  // Large region level (100km)
    if (map.getZoom() >= 7) clusterDistance = 50;   // State level (50km)
    if (map.getZoom() >= 9) clusterDistance = 20;   // Metro area level (20km)
    if (map.getZoom() >= 11) clusterDistance = 5;   // City level (5km)
    if (map.getZoom() >= 13) clusterDistance = 1;   // Neighborhood level (1km)
    
    
    // Distance calculation function
    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Filter photo locations by active filters
    let filteredPhotoLocations = photoLocations;
    
    // Filter by specific adventure if selected
    if (activeAdventureFilter) {
      filteredPhotoLocations = photoLocations.filter(photoLocation => {
        const adventureIdFromData = generateAdventureId(photoLocation.adventureTitle, photoLocation.adventure.date);
        return adventureIdFromData === activeAdventureFilter;
      });
    }
    // Otherwise filter by year if a year filter is active
    else if (activeYearFilter) {
      filteredPhotoLocations = photoLocations.filter(photoLocation => {
        return photoLocation.adventureYear === activeYearFilter;
      });
    }
    
    // Group photo locations by proximity
    const locationGroups = [];
    filteredPhotoLocations.forEach(photoLocation => {
      const [lat, lng] = photoLocation.coordinates.split(',').map(coord => parseFloat(coord.trim()));
      if (!isNaN(lat) && !isNaN(lng)) {
        
        // Find existing group within cluster distance
        let foundGroup = null;
        for (let group of locationGroups) {
          const distance = getDistance(lat, lng, group.centerLat, group.centerLng);
          if (distance <= clusterDistance) {
            foundGroup = group;
            break;
          }
        }
        
        if (foundGroup) {
          // Add to existing group and update center
          const totalPhotos = foundGroup.photos.length + 1;
          foundGroup.centerLat = ((foundGroup.centerLat * foundGroup.photos.length) + lat) / totalPhotos;
          foundGroup.centerLng = ((foundGroup.centerLng * foundGroup.photos.length) + lng) / totalPhotos;
          foundGroup.photos.push(photoLocation);
          
          // Update bounds to include this new point
          foundGroup.bounds.north = Math.max(foundGroup.bounds.north, lat);
          foundGroup.bounds.south = Math.min(foundGroup.bounds.south, lat);
          foundGroup.bounds.east = Math.max(foundGroup.bounds.east, lng);
          foundGroup.bounds.west = Math.min(foundGroup.bounds.west, lng);
          
          // Track unique adventures in this group
          const adventureKey = `${photoLocation.adventureTitle}_${photoLocation.adventure.date}`;
          if (!foundGroup.adventures.has(adventureKey)) {
            foundGroup.adventures.add(adventureKey);
            foundGroup.adventuresList.push(photoLocation.adventure);
          }
        } else {
          // Create new group
          const adventureKey = `${photoLocation.adventureTitle}_${photoLocation.adventure.date}`;
          locationGroups.push({
            centerLat: lat,
            centerLng: lng,
            photos: [photoLocation],
            adventures: new Set([adventureKey]),
            adventuresList: [photoLocation.adventure],
            location: photoLocation.adventureLocation,
            bounds: {
              north: lat,
              south: lat,
              east: lng,
              west: lng
            }
          });
        }
      }
    });

    // Update year button highlighting based on what's visible
    updateYearButtonHighlighting(locationGroups);

    // Create markers for each location group
    locationGroups.forEach(group => {
      const photoCount = group.photos.length;
      const adventureCount = group.adventuresList.length;
      
      // Create custom icon - all pins same blue color and size
      let iconHtml, iconSize;
      iconHtml = `<div class="map-pin single-pin"></div>`;
      iconSize = [16, 16];
      
      const customIcon = L.divIcon({
        html: iconHtml,
        className: 'custom-map-icon',
        iconSize: iconSize,
        iconAnchor: [iconSize[0]/2, iconSize[1]/2]
      });
      
      // Create streamlined popup content
      let popupContent = `<div class="map-popup">`;
      if (photoCount === 1) {
        const photo = group.photos[0];
        popupContent += `
          <h4>${photo.adventureTitle}</h4>
          <p>${photo.adventureYear} • ${photo.adventureLocation}</p>
        `;
      } else {
        const uniqueAdventures = [...new Set(group.photos.map(p => p.adventureTitle))];
        const locationName = group.photos[0].adventureLocation;
        const years = [...new Set(group.photos.map(p => p.adventureYear))].sort().reverse();
        
        popupContent += `
          <h4>${locationName}</h4>
          <p>${years.join(', ')} • ${photoCount} photos</p>
        `;
        
        if (uniqueAdventures.length <= 3) {
          popupContent += `<div class="adventure-list">`;
          uniqueAdventures.forEach(title => {
            popupContent += `<div class="adventure-item">${title}</div>`;
          });
          popupContent += `</div>`;
        } else {
          popupContent += `<div class="adventure-list">`;
          uniqueAdventures.slice(0, 2).forEach(title => {
            popupContent += `<div class="adventure-item">${title}</div>`;
          });
          popupContent += `<div class="adventure-item">+${uniqueAdventures.length - 2} more adventures</div>`;
          popupContent += `</div>`;
        }
      }
      popupContent += `</div>`;
      
      const marker = L.marker([group.centerLat, group.centerLng], { icon: customIcon })
        .addTo(map)
        .bindPopup(popupContent);
      
      marker.locationData = group;
      marker.on('click', function() {
        handleMarkerClick(group);
      });
      
      // Also show popup on hover
      marker.on('mouseover', function() {
        this.openPopup();
      });
      
      marker.on('mouseout', function() {
        this.closePopup();
      });
      
      markers.push(marker);
    });
  }

  // Handle marker click
  function handleMarkerClick(group) {
    const adventureCount = group.adventuresList.length;
    
    // Track map marker interaction
    trackEvent('map-marker-click', {
      location: group.location,
      photoCount: group.photos.length,
      adventureCount: adventureCount
    });
    
    if (adventureCount === 1) {
      // Single adventure - select it like clicking the card
      const adventure = group.adventuresList[0];
      // Use consistent adventure ID generation
      const adventureId = generateAdventureId(adventure.title, adventure.date);
      const storyItem = document.querySelector(`[data-adventure-id="${adventureId}"]`);
      
      if (storyItem) {
        handleAdventureCardClick(storyItem);
      }
      return;
    } else {
      // Multiple adventures - check if they're tightly clustered
      const bounds = group.bounds;
      
      // Calculate the range in degrees
      const latRange = bounds.north - bounds.south;
      const lngRange = bounds.east - bounds.west;
      
      // Convert to approximate kilometers (rough calculation for comparison)
      const latRangeKm = latRange * 111; // 1 degree lat ≈ 111km
      const lngRangeKm = lngRange * 111 * Math.cos(group.centerLat * Math.PI / 180); // longitude varies by latitude
      const maxRangeKm = Math.max(latRangeKm, lngRangeKm);
      
      
      // If pins are very close together (within ~5km), use gentle zoom
      if (maxRangeKm < 5) {
        const currentZoom = map.getZoom();
        const targetZoom = Math.min(currentZoom + 2, 15);
        
        
        // Simple zoom in by 2 levels and center
        map.setView([group.centerLat, group.centerLng], targetZoom);
        
        setTimeout(() => {
          currentZoomLevel = targetZoom;
          drawMarkers();
          filterToMapView();
        }, 500);
        
      } else {
        // Pins are spread out - use bounds-based zoom
        // Add 20% padding (120% total = original + 20% on each side)
        const paddingLat = latRange * 0.2;
        const paddingLng = lngRange * 0.2;
        
        // Create Leaflet bounds with padding
        const leafletBounds = L.latLngBounds([
          [bounds.south - paddingLat, bounds.west - paddingLng],
          [bounds.north + paddingLat, bounds.east + paddingLng]
        ]);
        
        
        // Fit the map to the bounds
        map.fitBounds(leafletBounds);
        
        setTimeout(() => {
          currentZoomLevel = map.getZoom();
          
          drawMarkers();
          filterToMapView();
        }, 500);
      }
    }
  }

  // Filter stories to show adventures represented on current map view
  function filterToMapView() {
    const stories = document.querySelectorAll('.story-item');
    const yearButtons = document.querySelectorAll('[data-year]');
    
    // Clear year filter buttons only if no year filter is active
    if (!activeYearFilter) {
      yearButtons.forEach(btn => btn.classList.remove('active'));
    }
    
    // Get current map bounds
    const bounds = map.getBounds();
    
    // Get all unique adventures from markers that are within the current map bounds
    const visibleAdventures = new Set();
    let markersInView = 0;
    
    markers.forEach((marker, index) => {
      const group = marker.locationData;
      const markerLatLng = L.latLng(group.centerLat, group.centerLng);
      
      // Check if this marker is within the current map bounds
      if (bounds.contains(markerLatLng)) {
        markersInView++;
        
        group.adventuresList.forEach(adventure => {
          // Create a unique key using title, date, and location
          const adventureKey = `${adventure.title}|${adventure.date}|${adventure.location}`;
          visibleAdventures.add(adventureKey);
        });
      }
    });
    
    let visibleCount = 0;
    let hiddenCount = 0;
    
    stories.forEach(story => {
      const storyTitle = story.querySelector('.story-title').textContent.trim();
      const storyLocation = story.getAttribute('data-location');
      const storyYear = story.getAttribute('data-year');
      
      // Check if this story matches any adventure visible on the map by title and location
      let isVisibleOnMap = false;
      
      // Simple match by title and location
      for (let adventureKey of visibleAdventures) {
        const [advTitle, advDate, advLocation] = adventureKey.split('|');
        
        if (advTitle === storyTitle && advLocation === storyLocation) {
          isVisibleOnMap = true;
          break;
        }
      }
      
      // Also check if it matches the active year filter (if any)
      let matchesYearFilter = true;
      if (activeYearFilter) {
        matchesYearFilter = (storyYear === activeYearFilter);
      }
      
      // Story is visible if it's on the map AND matches year filter
      const isVisible = isVisibleOnMap && matchesYearFilter;
      
      if (isVisible) {
        story.classList.remove('hidden');
        visibleCount++;
      } else {
        story.classList.add('hidden');
        hiddenCount++;
      }
    });
    
    
    // Update year button highlighting based on what COULD be visible in viewport
    // (check all photo locations in viewport, not just filtered ones)
    const currentBounds = map.getBounds();
    const allLocationGroupsInViewport = [];
    
    // Create temporary location groups from ALL photos (ignoring year filter) 
    const tempLocationGroups = [];
    photoLocations.forEach(photoLocation => {
      const [lat, lng] = photoLocation.coordinates.split(',').map(coord => parseFloat(coord.trim()));
      if (!isNaN(lat) && !isNaN(lng)) {
        const markerLatLng = L.latLng(lat, lng);
        
        // If this photo location is in the current viewport
        if (currentBounds.contains(markerLatLng)) {
          // Find or create a group for this adventure
          let existingGroup = tempLocationGroups.find(group => 
            group.adventureTitle === photoLocation.adventureTitle &&
            group.adventureDate === photoLocation.adventure.date
          );
          
          if (!existingGroup) {
            tempLocationGroups.push({
              adventureTitle: photoLocation.adventureTitle,
              adventureDate: photoLocation.adventure.date,
              adventuresList: [photoLocation.adventure]
            });
          }
        }
      }
    });
    
    updateYearButtonHighlighting(tempLocationGroups);
    
    activeLocationFilter = true; // Mark that we have an active map-based filter
  }

  // Reset location filter
  function resetLocationFilter() {
    if (activeLocationFilter) {
      const stories = document.querySelectorAll('.story-item');
      stories.forEach(story => story.classList.remove('hidden'));
      activeLocationFilter = null;
      
      // Reset map zoom (adjust for mobile)
      const isMobile = window.innerWidth <= 768;
      const resetZoom = isMobile ? 3 : 4;
      map.setView([39.8283, -98.5795], resetZoom);
      currentZoomLevel = resetZoom;
      
      // Redraw markers for national view
      setTimeout(() => {
        drawMarkers();
      }, 100);
    }
  }


  // Filter functions
  function filterByYear(year) {
    // Clear any adventure selection when manually selecting year
    if (selectedAdventureId) {
      deselectAdventure();
      return; // Exit early since deselectAdventure handles everything
    }
    
    const yearButtons = document.querySelectorAll('[data-year]');
    const clickedButton = document.querySelector(`[data-year="${year}"]`);
    
    // Don't reset location filter - keep current map position
    
    // Toggle button state - if already active, deactivate (show all)
    if (clickedButton.classList.contains('active')) {
      // Deactivate - show all years
      yearButtons.forEach(btn => btn.classList.remove('active'));
      activeYearFilter = null;
      
      // Track year filter removal
      trackEvent('year-filter-removed', { year: year });
      
      // Redraw map with all adventures at current position
      drawMarkers();
      
      // Filter stories based on current map view (now with no year filter)
      setTimeout(() => {
        filterToMapView();
      }, 100);
      
    } else {
      // Activate this year only
      yearButtons.forEach(btn => btn.classList.remove('active'));
      clickedButton.classList.add('active');
      activeYearFilter = year;
      
      // Track year filter selection
      trackEvent('year-filter-selected', { year: year });
      
      // Redraw map with only adventures from the selected year at current position
      drawMarkers();
      
      // Filter stories based on current map view and selected year
      setTimeout(() => {
        filterToMapView();
      }, 100);
    }
  }

  // Event listeners for year filters
  document.querySelectorAll('.filter-btn[data-year]').forEach(button => {
    button.addEventListener('click', function() {
      const year = this.getAttribute('data-year');
      filterByYear(year);
    });
  });


  // Direct adventure linking support
  function handleDirectAdventureLink() {
    const hashValue = decodeURIComponent(window.location.hash.substring(1));
    
    if (hashValue.startsWith('adventure:')) {
      const adventureId = hashValue.substring(10); // Remove 'adventure:' prefix
      filterToSingleAdventure(adventureId);
    }
  }
  
  function filterToSingleAdventure(adventureId) {
    // Find the adventure by ID (using title + date as identifier)
    const targetAdventure = adventures.find(adv => {
      const adventureIdFromData = generateAdventureId(adv.title, adv.date);
      return adventureIdFromData === adventureId;
    });
    
    if (!targetAdventure) return;
    
    
    // Find and select the target story item
    const targetStoryItem = document.querySelector(`[data-adventure-id="${adventureId}"]`);
    
    // Hide all stories except the target one
    document.querySelectorAll('.story-item').forEach(story => {
      if (story === targetStoryItem) {
        story.classList.remove('hidden');
        story.classList.add('selected');
      } else {
        story.classList.add('hidden');
        story.classList.remove('selected');
      }
    });
    
    selectedAdventureId = adventureId;
    
    // Set year filter to match the adventure
    const adventureYear = targetAdventure.year;
    activeYearFilter = adventureYear;
    activeAdventureFilter = adventureId;
    
    // Update year button states
    document.querySelectorAll('[data-year]').forEach(btn => {
      if (btn.getAttribute('data-year') === adventureYear) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
    
    // Filter map to show only this adventure
    drawMarkers();
    
    // Zoom map to fit the adventure's locations
    setTimeout(() => {
      zoomToAdventure(targetAdventure);
    }, 200);
    
    
    // Track direct adventure access
    trackEvent('adventure-direct-access', {
      adventureId: adventureId,
      adventureTitle: targetAdventure.title,
      adventureYear: adventureYear
    });
  }
  
  
  function clearAdventureFilter() {
    // Clear the hash
    programmaticHashChange = true;
    window.location.hash = '';
    setTimeout(() => { programmaticHashChange = false; }, 100);
    
    // Show all adventures and clear selection
    document.querySelectorAll('.story-item').forEach(story => {
      story.classList.remove('hidden');
      story.classList.remove('selected');
    });
    
    selectedAdventureId = null;
    
    // Clear filters
    activeYearFilter = null;
    activeAdventureFilter = null;
    document.querySelectorAll('[data-year]').forEach(btn => {
      btn.classList.remove('active');
    });
    
    // Reset map
    drawMarkers();
    
    // Reset map zoom to default view
    setTimeout(() => {
      map.setView([39.8283, -98.5795], 4);
    }, 100);
    
    
    // Track filter clear
    trackEvent('adventure-filter-cleared');
  }
  
  // Adventure selection state
  let selectedAdventureId = null;
  let programmaticHashChange = false;
  
  // Consistent adventure ID generation function (matches Jekyll template)
  function generateAdventureId(title, date) {
    // Date should already be in YYYY-MM-DD format
    return title.toLowerCase().replace(/\s/g, '-').replace(/[^a-z0-9-]/g, '') + '-' + date;
  }
  
  function handleAdventureCardClick(storyItem) {
    const adventureId = storyItem.getAttribute('data-adventure-id');
    const adventureTitle = storyItem.getAttribute('data-adventure-title');
    
    // Simple toggle logic based on visual state
    if (storyItem.classList.contains('selected')) {
      deselectAdventure();
    } else {
      selectAdventure(adventureId, adventureTitle, storyItem);
    }
  }
  
  function selectAdventure(adventureId, adventureTitle, storyItem) {
    // Clear any previous selection
    document.querySelectorAll('.story-item.selected').forEach(item => {
      item.classList.remove('selected');
    });
    
    // Select this adventure
    storyItem.classList.add('selected');
    selectedAdventureId = adventureId;
    
    // Update URL
    programmaticHashChange = true;
    window.location.hash = `adventure:${adventureId}`;
    setTimeout(() => { programmaticHashChange = false; }, 100);
    
    // Find the adventure data
    const targetAdventure = adventures.find(adv => {
      const adventureIdFromData = generateAdventureId(adv.title, adv.date);
      return adventureIdFromData === adventureId;
    });
    
    if (targetAdventure) {
      // Set year filter to match the adventure
      const adventureYear = targetAdventure.year;
      activeYearFilter = adventureYear;
      activeAdventureFilter = adventureId;
      
      // Update year button states
      document.querySelectorAll('[data-year]').forEach(btn => {
        if (btn.getAttribute('data-year') === adventureYear) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Hide other adventures
      document.querySelectorAll('.story-item').forEach(story => {
        if (story === storyItem) {
          story.classList.remove('hidden');
        } else {
          story.classList.add('hidden');
        }
      });
      
      // Update map and zoom
      drawMarkers();
      setTimeout(() => {
        zoomToAdventure(targetAdventure);
      }, 200);
      
    }
    
    // Track selection
    trackEvent('adventure-selected', {
      adventureId: adventureId,
      adventureTitle: adventureTitle
    });
  }
  
  function deselectAdventure() {
    
    // Clear selection styling
    document.querySelectorAll('.story-item.selected').forEach(item => {
      item.classList.remove('selected');
    });
    
    // Clear state
    selectedAdventureId = null;
    activeYearFilter = null;
    activeAdventureFilter = null;
    
    // Clear URL
    programmaticHashChange = true;
    window.location.hash = '';
    setTimeout(() => { programmaticHashChange = false; }, 100);
    
    // Show all adventures
    document.querySelectorAll('.story-item').forEach(story => {
      story.classList.remove('hidden');
    });
    
    // Clear year filter buttons
    document.querySelectorAll('[data-year]').forEach(btn => {
      btn.classList.remove('active');
    });
    
    // Reset map
    drawMarkers();
    setTimeout(() => {
      map.setView([39.8283, -98.5795], 4);
    }, 100);
    
    
    // Track deselection
    trackEvent('adventure-deselected');
  }
  
  // Add click event listeners to all story cards
  document.querySelectorAll('.story-item').forEach(storyItem => {
    storyItem.addEventListener('click', function(e) {
      // Don't trigger if clicking on photos or other interactive elements
      if (e.target.closest('.photo-container') || e.target.closest('a') || e.target.closest('button')) {
        return;
      }
      
      handleAdventureCardClick(this);
    });
  });
  
  // Add click event listeners to deselect buttons
  document.querySelectorAll('.deselect-button').forEach(button => {
    button.addEventListener('click', function(e) {
      e.stopPropagation(); // Prevent triggering the story card click
      deselectAdventure();
    });
  });
  
  // Set up impression tracking for adventure cards
  const observedAdventures = new Set();
  const adventureObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
        const storyItem = entry.target;
        const adventureId = storyItem.getAttribute('data-adventure-id');
        const adventureTitle = storyItem.getAttribute('data-adventure-title');
        const adventureYear = storyItem.getAttribute('data-year');
        
        // Only track each adventure impression once per session
        if (!observedAdventures.has(adventureId)) {
          observedAdventures.add(adventureId);
          
          trackEvent('adventure-impression', {
            adventureId: adventureId,
            adventureTitle: adventureTitle ? adventureTitle.substring(0, 50) : 'Unknown',
            adventureYear: adventureYear
          });
        }
      }
    });
  }, {
    threshold: 0.5, // Trigger when 50% of the card is visible
    rootMargin: '0px'
  });
  
  // Observe all adventure cards
  document.querySelectorAll('.story-item').forEach(storyItem => {
    adventureObserver.observe(storyItem);
  });
  
  // Handle hash changes (back/forward buttons)
  window.addEventListener('hashchange', function() {
    // Skip if this was a programmatic change from our click handlers
    if (programmaticHashChange) {
      return;
    }
    
    const hashValue = decodeURIComponent(window.location.hash.substring(1));
    
    if (hashValue.startsWith('adventure:')) {
      handleDirectAdventureLink();
    } else if (hashValue === '') {
      // Hash cleared, clear any adventure selection
      if (selectedAdventureId) {
        deselectAdventure();
      }
    }
  });

  // Initialize everything
  if (typeof L !== 'undefined') {
    initMap();
    
    // Check for direct adventure link on page load
    handleDirectAdventureLink();
    
    // Apply custom focus positioning to photos
    applyPhotoFocus();
    
    // Track adventures page load
    trackEvent('adventures-page-loaded', {
      totalStories: adventures.length,
      totalPhotos: photoLocations.length
    });
  }
  
  // Apply custom focus positioning to photos
  function applyPhotoFocus() {
    document.querySelectorAll('.photo-container').forEach(container => {
      const focus = container.dataset.focus;
      const img = container.querySelector('img');
      
      if (img && focus && focus !== 'center') {
        // Handle percentage values (e.g., "30%" for 30% from top)
        if (focus.includes('%')) {
          if (focus.match(/^\d+%$/)) {
            // Vertical percentage (e.g., "30%" = 30% from top)
            img.style.objectPosition = `center ${focus}`;
          } else if (focus.match(/^\d+%\s+\d+%$/)) {
            // Both horizontal and vertical (e.g., "20% 30%")
            img.style.objectPosition = focus;
          }
        }
        // Handle custom position strings (e.g., "left 20%", "right top")
        else if (focus.includes(' ') && !container.classList.contains(`focus-${focus}`)) {
          img.style.objectPosition = focus;
        }
      }
    });
  }
});
</script>

<!-- Photo Modal JavaScript -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('photo-modal');
  const modalImage = document.getElementById('photo-modal-image');
  const modalCaption = document.getElementById('photo-modal-caption');
  const modalClose = document.getElementById('photo-modal-close');
  const colorCanvas = document.getElementById('color-extraction-canvas');
  const colorCtx = colorCanvas.getContext('2d');
  
  // Function to extract dominant colors from image
  function extractColors(img) {
    // Set canvas size to a smaller version for performance
    const maxSize = 100;
    const ratio = Math.min(maxSize / img.naturalWidth, maxSize / img.naturalHeight);
    colorCanvas.width = img.naturalWidth * ratio;
    colorCanvas.height = img.naturalHeight * ratio;
    
    // Draw image to canvas
    colorCtx.drawImage(img, 0, 0, colorCanvas.width, colorCanvas.height);
    
    // Extract colors from all four sides
    const sampleSize = 0.1; // 10% of image from each side
    const sides = {
      top: {
        x: 0, y: 0,
        width: colorCanvas.width,
        height: Math.floor(colorCanvas.height * sampleSize)
      },
      bottom: {
        x: 0, y: colorCanvas.height - Math.floor(colorCanvas.height * sampleSize),
        width: colorCanvas.width,
        height: Math.floor(colorCanvas.height * sampleSize)
      },
      left: {
        x: 0, y: 0,
        width: Math.floor(colorCanvas.width * sampleSize),
        height: colorCanvas.height
      },
      right: {
        x: colorCanvas.width - Math.floor(colorCanvas.width * sampleSize), y: 0,
        width: Math.floor(colorCanvas.width * sampleSize),
        height: colorCanvas.height
      }
    };
    
    const sideColors = {};
    
    // Extract dominant color from each side
    Object.keys(sides).forEach(side => {
      const { x, y, width, height } = sides[side];
      const imageData = colorCtx.getImageData(x, y, width, height);
      const data = imageData.data;
      
      const colors = {};
      for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const key = `${Math.floor(r/20)*20},${Math.floor(g/20)*20},${Math.floor(b/20)*20}`;
        colors[key] = (colors[key] || 0) + 1;
      }
      
      // Find most common color for this side
      let dominantColor = '60,60,60'; // Default
      let maxCount = 0;
      for (const [color, count] of Object.entries(colors)) {
        if (count > maxCount) {
          maxCount = count;
          dominantColor = color;
        }
      }
      
      sideColors[side] = dominantColor;
    });
    
    return sideColors;
  }
  
  // Function to create extended background from side colors
  function createExtendedBackground(sideColors) {
    const { top, bottom, left, right } = sideColors;
    
    // Parse colors
    const topRGB = top.split(',').map(Number);
    const bottomRGB = bottom.split(',').map(Number);
    const leftRGB = left.split(',').map(Number);
    const rightRGB = right.split(',').map(Number);
    
    // Calculate average brightness for text color
    const avgBrightness = (topRGB.concat(bottomRGB, leftRGB, rightRGB).reduce((sum, val) => sum + val, 0) / 12) * 0.299;
    const textColor = avgBrightness > 128 ? '#333333' : '#ffffff';
    
    // Create radial gradient extending from center outward
    const centerColor = [topRGB, bottomRGB, leftRGB, rightRGB]
      .reduce((acc, rgb) => acc.map((val, i) => val + rgb[i]), [0, 0, 0])
      .map(val => Math.floor(val / 4));
    
    return {
      background: `
        radial-gradient(ellipse at center, 
          rgba(${centerColor[0]},${centerColor[1]},${centerColor[2]},0.3) 0%,
          rgba(${topRGB[0]},${topRGB[1]},${topRGB[2]},0.6) 20%,
          rgba(${leftRGB[0]},${leftRGB[1]},${leftRGB[2]},0.7) 40%,
          rgba(${rightRGB[0]},${rightRGB[1]},${rightRGB[2]},0.7) 60%,
          rgba(${bottomRGB[0]},${bottomRGB[1]},${bottomRGB[2]},0.8) 80%,
          rgba(${Math.max(0, bottomRGB[0] - 40)},${Math.max(0, bottomRGB[1] - 40)},${Math.max(0, bottomRGB[2] - 40)},0.95) 100%
        )
      `,
      color: textColor,
      backdropFilter: 'blur(15px)'
    };
  }
  
  // Helper function to track events in Umami
  function trackEvent(eventName, eventData = {}) {
    if (typeof umami !== 'undefined') {
      umami.track(eventName, eventData);
    }
  }
  
  // Add click event to all photo containers
  document.querySelectorAll('.photo-container').forEach(container => {
    container.addEventListener('click', function() {
      const imageName = this.getAttribute('data-image');
      const caption = this.getAttribute('data-caption');
      const longCaption = this.getAttribute('data-long-caption');
      
      // Load high-res image
      const highResPath = `/assets/img/adventures/${imageName}`;
      modalImage.src = highResPath;
      modalImage.alt = caption;
      
      // Clear caption initially
      modalCaption.textContent = '';
      
      // Reset caption styling to default
      modalCaption.style.background = 'white';
      modalCaption.style.color = '#333333';
      modalCaption.style.backdropFilter = '';
      
      // Extract colors when image loads
      modalImage.onload = function() {
        
        // Set caption width to match image width
        const updateCaptionWidth = () => {
          const imageWidth = modalImage.clientWidth;
          modalCaption.style.width = imageWidth + 'px';
          modalCaption.style.maxWidth = imageWidth + 'px';
        };
        
        updateCaptionWidth();
        
        // Update caption width on window resize
        window.addEventListener('resize', updateCaptionWidth);
        
        // Store the resize handler for cleanup
        modalImage.resizeHandler = updateCaptionWidth;
        
        try {
          // Wait a bit for image to render, then extract colors
          setTimeout(() => {
            const sideColors = extractColors(modalImage);
            const extendedStyle = createExtendedBackground(sideColors);
            
            // Apply extended background to modal content
            const modalContent = document.querySelector('.photo-modal-content');
            modalContent.style.background = extendedStyle.background;
            modalContent.style.backdropFilter = extendedStyle.backdropFilter;
            
            // Keep modal background dark with blur
            modal.style.background = 'rgba(0, 0, 0, 0.8)';
            modal.style.backdropFilter = 'blur(5px)';
            
            // Apply text color and background to caption
            modalCaption.style.setProperty('color', extendedStyle.color, 'important');
            modalCaption.style.textShadow = extendedStyle.color === '#ffffff' ? '0 1px 3px rgba(0,0,0,0.5)' : '0 1px 3px rgba(255,255,255,0.5)';
            
            // Apply a solid version of the background to the caption for consistent scrolling
            const centerColor = [
              ...Object.values(sideColors).map(color => color.split(',').map(Number))
            ].reduce((acc, rgb) => acc.map((val, i) => val + rgb[i]), [0, 0, 0])
            .map(val => Math.floor(val / 4));
            
            modalCaption.style.background = `rgba(${centerColor[0]},${centerColor[1]},${centerColor[2]},0.3)`;
            
            // Create a custom CSS rule to ensure text color consistency during scrolling
            const captionStyleId = 'caption-color-override';
            let existingStyle = document.getElementById(captionStyleId);
            if (existingStyle) {
              existingStyle.remove();
            }
            
            const style = document.createElement('style');
            style.id = captionStyleId;
            style.textContent = `
              .photo-modal-caption {
                color: ${extendedStyle.color} !important;
              }
              .photo-modal-caption::selection {
                color: ${extendedStyle.color} !important;
                background: rgba(255, 255, 255, 0.2);
              }
            `;
            document.head.appendChild(style);
            
            // Set caption content AFTER applying all styling
            modalCaption.innerHTML = `<span style="color: ${extendedStyle.color} !important;">${longCaption || caption}</span>`;
          }, 100);
        } catch (error) {
          // Fallback to default styling
          modal.style.background = 'rgba(0, 0, 0, 0.9)';
          modal.style.backdropFilter = 'blur(10px)';
          modalCaption.style.color = '#ffffff';
          modalCaption.style.textShadow = '0 1px 3px rgba(0,0,0,0.5)';
          modalCaption.style.background = 'rgba(255, 255, 255, 0.1)';
          
          // Set caption content with fallback styling
          modalCaption.innerHTML = `<span style="color: #ffffff !important;">${longCaption || caption}</span>`;
        }
      };
      
      // Track photo view event
      trackEvent('photo-view', {
        image: imageName,
        caption: caption
      });
      
      // Show modal
      modal.classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent scrolling
    });
  });
  
  // Close modal events
  function closeModal() {
    modal.classList.remove('active');
    document.body.style.overflow = ''; // Restore scrolling
    
    // Clean up resize listener
    if (modalImage.resizeHandler) {
      window.removeEventListener('resize', modalImage.resizeHandler);
      modalImage.resizeHandler = null;
    }
    
    // Clean up custom caption color style
    const captionStyleId = 'caption-color-override';
    const existingStyle = document.getElementById(captionStyleId);
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Track modal close event
    trackEvent('photo-modal-close');
  }
  
  modalClose.addEventListener('click', closeModal);
  
  // Close when clicking outside the image
  modal.addEventListener('click', function(e) {
    if (e.target === modal) {
      closeModal();
    }
  });
  
  // Close with Escape key
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && modal.classList.contains('active')) {
      closeModal();
    }
  });
});
</script>
{% endif %}